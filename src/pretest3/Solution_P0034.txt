6
3333 10
143 20
667 20
667 30
2573 30
2573 40






(출력)
#1 GOOD
#2 BAD 11
#3 GOOD
#4 BAD 23
#5 GOOD
#6 BAD 31


※ Java의 경우 java.math 패키지를 사용할 수 없음.

젊고 매우 촉망받는 암호학자 OddEven씨는 그의 회사에서 수천 명의 직원이 사용하는 
대형 시스템의 보안 모듈을 구현했다. 이 모듈의 암호키는 두 개의 소수(prime number)의
곱의 값으로 생성되며, 이 두 개의 소수를 알아채는 효과적인 방법이 발견되지 않았으므로
지금까지는 이 암호키가 안전하다고 믿고 사용되고 있다.

하지만 OddEven씨가 미처 생각하지 못했던 것이 있었다. 암호키만 충분히 큰 값이라면 안전할 줄 알았지만
면밀히 확인한 결과 그 암호키를 만들 때 사용되는, 앞서 언급한 두 개의 소수 중 어느 하나라도 충분히
크지 않다면 암호키 자체가 보안에 취약할 수 있다는 것이었다.

뒤늦게 이 사실을 알아낸 OddEven씨는 이대로 암호키 생성과 사용을 계속 한다면
언젠가 큰 보안사고가 발생하여 회사에서 해고당할 수도 있다는 위기감에 빠졌기에,
회사에서 사용되고 있는 암호키를 하나하나 면밀히 조사하기로 하였다.

OddEven씨를 도와, 주어진 암호키를 사용해도 좋은 것인지 그렇지 않은 것인지를 확인하는 프로그램을
작성하여라.

[입력]
맨 처음 테스트 케이스의 개수 T 가 주어지고, 다음 줄부터 T 개의 테스트 케이스가 주어진다.
각 테스트 케이스는 한 줄로 구성되어 있으며, 두 개의 정수 K 와 L 이 공백으로 구분되어 순서대로 주어진다.
여기서 K 는 조사해야 할 암호키를 의미고, 두 소수의 곱으로 이루어진 수이다( 4 ≤ K ≤ 10100 ).
그리고 L 은 2 이상 106 이하의 정수이며, K 의 제작에 사용되는 두 소수 모두 L 이상이어야만
암호키로서 K 를 사용해도 괜찮다는 의미이다.

[출력]
각 테스트 케이스에 대한 답을 테스트 케이스 당 한줄로 출력한다.
맨 처음 #x(x 는 테스트케이스의 번호, 1부터 시작) 을 출력한 후 공백을 하나 두고,
K 가 사용해도 괜찮은 암호라면 GOOD 을 출력하면 되고, 그렇지 않다면 BAD 를 출력한 후 공백을 하나 두고 p 를 출력한다.
이 때 p 는 L 미만의 소수로서 K 를 나눌 수 있는 수를 뜻하며, 그러한 수가 둘 이상이면 그 중 가장 작은 수를 출력한다.
(출력 예 참고)
