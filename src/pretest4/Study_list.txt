6일차 교육 (그래프-기초, 크루스칼, 프림)
- 트리그래프 : 순환하지않는다, 두정점간 1개의 단순경로만 존재, 하나의 간선 제거시 연결되지 않는다.
- 간선리스트(E*2), 인접행렬(V*V), 인접리스트(V + E, ArrayList V) 

Solution_EP0023.java - (중상) [연습P-0023] 동맹의 동맹은 동맹 (Union-Find) : OK
Solution_SP0008.java - (중상) [교육P-0008] 임계 경로 (위상)
Solution_EP0007.java - (중상) [교육P-0007] 군사 도로망 (크루스칼)

Solution_EA0002.java - 과제 - (중) [연습A-0002] 키순서 (BFS, DFS)




7일차 교육 (그래프-LCA, 다익스트라)

Solution_SP0026.java - (중상) [교육P-0026] 최저 공통 조상 (LCA)
Solution_TA0037.java - (중) [기출A-0037] 핵심도시1 
Solution_EA0006.java - (중) [연습A-0006] 집으로 (다익스트라)

Solution_TP0051.java - 과제 - (중상) [기출P-0051] 조상이 키컸으면 (LCA)

(중상) [연습P-0010] 상인 (LCA)


8일차 교육 (밸만-포워드, 플로이드-워셜)
Solution_EP0008.java - (중상) [연습P-0008] 웜홀
Solution_SP0006.java - (중상) [교육P-0006] 가장 먼 두 도시

Solution_SP0009.java - 과제 - (중상) [교육P-0009] 최단 경로 (다익스트라)


Solution_TEST3.java - 모의고사 - (중상) [연습P-0012] 파티 참석하기 (다익스트라)




그래프의 특징
- 어느정도는 알고리즘이 정해져있다. 
  (예 : 다익스트라, 크루스칼, union-find 등등)
  (일정하게 유사한 풀이법이 존재한다.)
- 알고리즘 구동에 관한 이해가 있어야한다.
- pro 문제는 알고리즘 그대로 적용하는 문제는 거의 나오지 않음

그래프의 표현
2. 간선리스트 : 간선의 나열, 간선수 * 2 만큼의 공간이 필요
3. 인접행렬 : V * V 배열선언, 배열[i][j] = i 에서 j 갈수 있으면 1 (가중치) 아니면 0
1. 인접리스트 : 간선의 갯수만큼  인접리스트(Arraylist, Vector) 배열을 선언해서
                    배열[v] 에 v 와 연결된 간선들의 정보를 넣는다.
                   (가중치가 있는 그래프는 가중치도 같이 넣습니다. > 자바는 class , C 는 struct

union-find

- 초기화 : 각자가 스스로를 바라볼수 있게 (self loop)
- find 함수 : 내가 스스로 보는 값이 나올때 까지 계속 반복 .. (재귀)
          이때 나의 부모 배열에 return 값을 다시 넣음으로써 다시 찾아올때 시간 단축!!
- union 함수 : 합치고자 하는 두점의 집합 대표번호를 찾아서 ... find ... 
                  두 점을 연결한다 (두점의 연결 순서는 상관 없음)

                   
임계경로 (위상정렬) (~4시까지 풀이)
- ArrayList 나 vector 를 활용해서 그래프를 그린다.
- 진입차수 배열을 만들어서 진입차수들을 계산한다.
  1 -> 5 로 간다. 그러면 5의 진입차수 +1 
- 큐나 스택을 이용해서, 
   진입차수가 0인 정점을 저장하는 공간을 만든다.  
- 큐나 스택에서 하나씩 빼서,
   해당 정점에 간선으로 연결된 정점들의 시간을 갱신하고,
   진입차수를 하나씩 내린다. 
   ( 진입차수가 0이 되면 다시 큐에 넣는다.)
- 큐또는 스택이 빌때까지 반복한다.
                   
                   
                   
군사도로망
- 이미 건설된 도로들을 음수처리해서,
  Union 하면 정답갱신을하지않고, 
  이미 연결된 정점들이면 정답갱신을 하고 넘어갑니다.
최소신장트리(MST, 크루스칼 알고리즘을 사용한 풀이)
- union-find 자료 구조를 사용한다.
- 간선리스트 형태로 간선들을 나열한다. (배열) 
   (정점1, 정점2, 간선비용)
   (자바는 Class, C 나 Cpp 은 Struct 를 사용)
- 간선비용을 기준으로  위에서 만든 배열을 정렬한다.
   (또는 우선순위 Queue에 담아둔다.)
- 간선비용이 작은 간선부터 하나씩 빼면서 MST 를 구성한다.
   이때, 간선에 연결된 두 정점이 같은 집합에 속해있다면 
   (즉 연결되어 있다면 = 두 정점을 find 했는데 같은 결과가 나오면)
   해당 간선은 Pass 한다.
   같은 집합이 아니라면, 두 정점을 연결하고, union 한다. 
- 정점갯수 - 1 개 만큼 간선을 소비했다면 (union 했다면) 종료.
                   


           
DFS
// 일반적인 dfs
function dfs(int s)
{
   visit[s]=true;
   for(int e : s 의 인접리스트){
      if(visit[e]==false){
          dfs(e)
      }   
   }
}
// inorder 와 outorder 구하는 dfs
function dfs(int s)
{
   seq++;
   visit[s]=true;
   inorders[s]=seq
   for(int e : s 의 인접리스트){
      if(visit[e]==false){
          dfs(e)
      }   
   }
   outorders[s]=seq
}


단절점을 구하는 방식
- dfs 를 구현한다.
- 방문하는 순서를 정한다 . (order)
- 인접하는 경로들을 돌면서 아래의 활동을한다.
  . 이미 방문한 정점이면 
    > 해당 정점의 order를 내 low 와 비교해서 처리
  . 방문하지 않은 정점이라면
    > 해당 정점에 대해서 dfs 를 실행시켜서 리턴되는 low 값 저장
       리턴된 low 값을 내 order랑 비교해서 단절점인지 체크
       리턴된 low 값을 내 low 랑 비교해서 갱신
       (시작점이라면 dfs 를 호출한 횟수를 체크해서 단절점인지 파악)
- 해당 dfs 가 종료되면서 low 값 리턴





다익스트라 알고리즘
- 특정점정에서 각 정점으로 가는 최단경로를 구하는 알고리즘
- 우선순위큐를 사용하는 알고리즘 개선을 통해서 시간복잡도 개선이 가능함
- Bfs 와 유사하게 우선순위큐 를 가지고 빌때 까지 점검
- 아래와 같은 로직으로 계산한다.
  1. 우선순위 큐를 선언한다. (초기값으로 출발지/0 의 값을 setting)
  2. 모든 거리배열을 초기화한다. (출발지는 0으로 setting)
  3. 우선순위 큐가 빌때까지 아래의 구문을 반복한다.
   3-1 우선순위 큐에서 값 (정점, 거리) 를 하나 뺀다.
   3-2 큐에서 뺀 값과 이미 거리배열에 있는 거리값을 비교해서, 
         큐에서 나온값이 더 크면 하위의 로직을 수행치 않고 넘어간다.
   3-3 큐에서 나온 정점을 기준정점으로 삼아서, 주위의 정점들의 거리값을 갱신한다.
   3-4 큐에서 나온 값 + 기준점에서 인접 정점으로 가는값과, 
         현재 인접 정점의 거리값을 비교해서 갱신
   3-5 값이 갱신되는 경우에는 해당 인접정점 및 갱신된 값을 다시 큐에 넣는다. 
- 위의 로직들이 모두 수행되면, 거리배열에 모든 정점까지의 최단거리가 저장된다.
- 단일 도착(single-destination) 최단 경로의 문제에 응용할수 있다.
   (그래프 내의 간선들을 뒤집으면 단일 출발 최단거리 문제로 바뀔 수 있다.)
   
   
벨만포드 알고리즘
- 특정점정에서 각 정점으로 가는 최단경로를 구하는 알고리즘
- vs 다익스트라 : 음수간선이 있어도 계산가능, 음수싸이클을 찾을수 있다.
- 간선리스트 형태로 간선을 배열에 담아두는게 구현이 편리하다.
- 간선수 - 1 만큼  모든 간선들을 탐색해서 거리를 갱신합니다.
  (초기값은 출발지만 0 이고, 나머지는 특정한 초기값)
- 최단거리를 찾은후에 , 한번더 모든 간선들을 탐색해서
  거리가 갱신된다면, 이는 음수 싸이클을 가진다.
  
  
플로이드 워셜
- 모든 간선쌍들의 최단 경로를 구할때 사용되는 알고리즘.
- O(V^3) 만큼의 시간이 소요된다. (즉 V 가 크면 사용할수 없다.)
- 아래의 For 3 중첩문으로 구성된다
for(a, 1~V)
  for(b, 1~V)
    for(c, 1~V)
       b→c 를 a 를 거쳐서 가는 경로를 찾아보고 거리를 갱신
       (b→a 가는게 존재하고, a→c 가 존재하면 b→a + a→c 와 b→c 를 비교.
  
   
                   